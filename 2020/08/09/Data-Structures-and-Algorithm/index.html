<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo/css/main.css">



<link rel="stylesheet" href="//unpkg.com/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//unpkg.com/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"riveryoung.cn","root":"/hexo/","scheme":"Mist","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="Array&#x2F;String数组和链表的区别数组是连续的；链表是不连续的； 数组是存放在栈区的，由系统自动分配；链表存方在堆区，由程序员动态分配内存； 数组的访问元素速度快，时间复杂度是O(1)，链表访问元素速度慢，时间复杂度是O(n)； 数组的插入或删除时间复杂度是O(n)，链表的时间复杂度是O(1)； 剑指 Offer 04. 二维数组中的查找 剑指 Offer 04. 二维数组中的查找在一个 n">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structures and Algorithm">
<meta property="og:url" content="http://riveryoung.cn/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/index.html">
<meta property="og:site_name" content="River Young">
<meta property="og:description" content="Array&#x2F;String数组和链表的区别数组是连续的；链表是不连续的； 数组是存放在栈区的，由系统自动分配；链表存方在堆区，由程序员动态分配内存； 数组的访问元素速度快，时间复杂度是O(1)，链表访问元素速度慢，时间复杂度是O(n)； 数组的插入或删除时间复杂度是O(n)，链表的时间复杂度是O(1)； 剑指 Offer 04. 二维数组中的查找 剑指 Offer 04. 二维数组中的查找在一个 n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer58.png">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer09.png">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer03.png">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer52a.png">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer52b.png">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/sort.jpg">
<meta property="og:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/bubble_sort.webp">
<meta property="article:published_time" content="2020-08-09T06:04:07.000Z">
<meta property="article:modified_time" content="2020-08-27T17:00:34.327Z">
<meta property="article:author" content="River Young">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://riveryoung.cn/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer58.png">


<link rel="canonical" href="http://riveryoung.cn/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Data Structures and Algorithm | River Young</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">River Young</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">爱技术/爱拍照</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/hexo/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/hexo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/hexo/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-String"><span class="nav-number">1.</span> <span class="nav-text">Array&#x2F;String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">数组和链表的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.</span> <span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-1"><span class="nav-number">1.3.</span> <span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.4.</span> <span class="nav-text">剑指 Offer 05.替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">剑指 Offer 17. 打印从 1 到最大的 n 位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.6.</span> <span class="nav-text">剑指 Offer 11. 旋转数组的最小数字 - 解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">1.7.</span> <span class="nav-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">1.8.</span> <span class="nav-text">剑指 Offer 29. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">1.9.</span> <span class="nav-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-57-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">1.10.</span> <span class="nav-text">剑指 Offer 57. 和为 s 的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-58-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.11.</span> <span class="nav-text">剑指 Offer 58. 翻转单词顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.12.</span> <span class="nav-text">剑指 Offer 58. 左旋转字符串 - 解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-Stack"><span class="nav-number">2.</span> <span class="nav-text">Queue&#x2F;Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">剑指 Offer 06. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">剑指 Offer 09. 用两个栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">2.3.</span> <span class="nav-text">剑指 Offer 30. 包含 min 函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals-%E6%96%B9%E6%B3%95%E5%92%8C-%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.3.1.</span> <span class="nav-text">.equals()方法和&#x3D;&#x3D;相等判断有什么区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashSet-HashMap"><span class="nav-number">3.</span> <span class="nav-text">HashSet&#x2F;HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">3.1.</span> <span class="nav-text">剑指 Offer 03. 数组中重复的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">3.2.</span> <span class="nav-text">剑指 Offer 50. 第一个只出现一次的字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">4.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">4.1.</span> <span class="nav-text">剑指 Offer 18. 删除链表的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">剑指 Offer 22. 链表中倒数第 k 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">4.3.</span> <span class="nav-text">剑指 Offer 25. 合并两个排序的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">4.4.</span> <span class="nav-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree"><span class="nav-number">5.</span> <span class="nav-text">Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search"><span class="nav-number">6.</span> <span class="nav-text">Search</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sort"><span class="nav-number">7.</span> <span class="nav-text">Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bubble-Sort"><span class="nav-number">7.1.</span> <span class="nav-text">Bubble Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selection-Sort"><span class="nav-number">7.2.</span> <span class="nav-text">Selection Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert-Sort"><span class="nav-number">7.3.</span> <span class="nav-text">Insert Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shell-sort"><span class="nav-number">7.4.</span> <span class="nav-text">Shell sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">7.5.</span> <span class="nav-text">Quick Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">7.6.</span> <span class="nav-text">Merge Sort</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">8.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">River Young</p>
  <div class="site-description" itemprop="description">科技呵护未来</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/hexo/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://riveryoung.cn/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="River Young">
      <meta itemprop="description" content="科技呵护未来">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="River Young">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Data Structures and Algorithm
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-09 14:04:07" itemprop="dateCreated datePublished" datetime="2020-08-09T14:04:07+08:00">2020-08-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-08-28 01:00:34" itemprop="dateModified" datetime="2020-08-28T01:00:34+08:00">2020-08-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/hexo/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Array-String"><a href="#Array-String" class="headerlink" title="Array/String"></a>Array/String</h2><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h3><p>数组是连续的；链表是不连续的；</p>
<p>数组是存放在栈区的，由系统自动分配；链表存方在堆区，由程序员动态分配内存；</p>
<p>数组的访问元素速度快，时间复杂度是O(1)，链表访问元素速度慢，时间复杂度是O(n)；</p>
<p>数组的插入或删除时间复杂度是O(n)，链表的时间复杂度是O(1)；</p>
<h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><blockquote>
<h3 id="剑指-Offer-04-二维数组中的查找-1"><a href="#剑指-Offer-04-二维数组中的查找-1" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>限制：</p>
<p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
</blockquote>
<p><strong>结题思路：</strong></p>
<p>​    第一种是使用暴力破解的方法，遍历整个二维数组直到找到target值或者遍历结束为止，但是该方法是时间复杂度为O(n*m)，不是最优解；</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  剑指offer04.二维数组中的查找</span></span><br><span class="line"><span class="comment">*   方法1：暴力破解的方法</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(n*m)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">                width = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    第二种方法是利用矩阵“从上到下递增，从左到右递增”的特点，将其视为二分查找树，所以可以取左下角的值”18”作为根节点进行开始判断，如果target小于18则往上走一行，如果大于18则往右走一列，直到找到target或者遍历结束为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  剑指offer04.二维数组中的查找</span></span><br><span class="line"><span class="comment">*   方法二</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] &gt; target)&#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target)&#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05.替换空格"></a>剑指 Offer 05.替换空格</h3><blockquote>
<p>剑指 Offer 05. 替换空格<br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<p>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>​    增加一个新字符串，遍历原来的字符串，遍历过程中，如果非空格则将原来的字符直接拼接到新字符串中，如果遇到空格则将%20拼接到新字符串中<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  剑指 Offer 05. 替换空格</span></span><br><span class="line"><span class="comment">*  时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">*  空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">//StringBuilder和String的区别</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;%2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String str = sb.toString();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrxy/p/8057657.html">StringBuilder和String的区别</a></p>
<h3 id="剑指-Offer-17-打印从-1-到最大的-n-位数"><a href="#剑指-Offer-17-打印从-1-到最大的-n-位数" class="headerlink" title="剑指 Offer 17. 打印从 1 到最大的 n 位数"></a>剑指 Offer 17. 打印从 1 到最大的 n 位数</h3><blockquote>
<p>剑指 Offer 17. 打印从 1 到最大的 n 位数<br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
<p>说明：</p>
<p>用返回一个整数列表来代替打印<br>n 为正整数</p>
</blockquote>
<p><strong>解题思路：</strong><br>    题目要求打印 “从 1 至最大的 n位数的列表” ，因此需考虑以下两个问题：</p>
<p>​    最大的 n 位数（记为 end ）和位数 n 的关系： 例如最大的 1位数是 9，最大的 2 位数是 99 ，最大的 3 位数是 999 。则可推出公式：<br>​    <code>end = 10^n - 1</code></p>
<p>​    <code>大数越界问题</code>： 当 n 较大时，end 会超出 int32整型的取值范围，超出取值范围的数字无法正常存储。但由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此不考虑大数越界问题。<br>因此，只需定义区间 [1, 10^n - 1][1,10 n −1] 和步长 11 ，通过 forfor 循环生成结果列表 res 并返回即可。</p>
<p><strong>复杂度分析：</strong><br>    时间复杂度 O(10^n ) ： 生成长度为 10^n 的列表需使用 O(10^n)时间。<br>    空间复杂度 O(1) ： 建立列表需使用 O(1)大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   剑指Offer17. 打印从 1 到最大的 n 位数</span></span><br><span class="line"><span class="comment">*   时间复杂度 ：O(10n)</span></span><br><span class="line"><span class="comment">*   空间复杂度 ：O(10n)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> number) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, (<span class="keyword">double</span>) number) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = i + <span class="number">1</span>;</span><br><span class="line">        System.out.println(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-11-旋转数组的最小数字-解决方案"><a href="#剑指-Offer-11-旋转数组的最小数字-解决方案" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字 - 解决方案"></a>剑指 Offer 11. 旋转数组的最小数字 - 解决方案</h3><blockquote>
<p>题目描述<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
</blockquote>
<p><strong>解题思路</strong></p>
<p>标签：二分查找<br>整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果<br>时间复杂度：O(logn)，空间复杂度：O(1)</p>
<p><strong>算法流程</strong><br>初始化下标 <code>left</code> 和 <code>right</code><br>每次计算中间下标 <code>mid = (right + left) / 2</code>，这里的除法是取整运算，不能出现小数；</p>
<p>当 <code>numbers[mid] &lt; numbers[right]</code> 时，说明最小值在 <code>[left, mid]</code> 区间中，则令 <code>right = mid</code>，用于下一轮计算；</p>
<p>当 <code>numbers[mid] &gt; numbers[right]</code> 时，说明最小值在 <code>[mid, right]</code> 区间中，则令 <code>left = mid + 1</code>，用于下一轮计算；</p>
<p>当 <code>numbers[mid] == numbers[right]</code> 时，无法判断最小值在哪个区间之中，此时让 <code>right--</code>，缩小区间范围，在下一轮进行判断；<br><strong>为什么是 right– 缩小范围，而不是 left++？</strong><br>    因为数组是升序的，所以最小值一定靠近左侧，而不是右侧<br>比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  剑指 Offer 11. 旋转数组的最小数字</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3><blockquote>
<p>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 解决方案<br>题目描述<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。<br>提示：</p>
<p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：双指针<br>整体思路：首先指定前指针 <code>start</code> 和后指针 <code>end</code>，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成<br>时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>初始化前指针 <code>start</code> = 0，后指针 <code>end = nums.length - 1</code><br>当 <code>start</code> &lt; <code>end</code> 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换<br>当 <code>nums[start]</code> 为奇数时，则 <code>start++</code>，直到找到不为奇数的下标为止<br>当 <code>nums[end]</code> 为偶数时，则 <code>end--</code>，直到找到不为偶数的下标为止<br>交换 <code>nums[start]</code> 和 <code>nums[end]</code>，继续下一轮交换<br>返回 <code>nums</code>，即为交换后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] number) &#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> even = number.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (odd &lt; even) &#123;</span><br><span class="line">        <span class="keyword">while</span>(number[odd] % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; odd &lt; even)&#123; <span class="comment">//判断奇数偶数也可以使用高效模式 (number &amp; 1) != 0 为奇数，否则为偶数 相比于求余法有25%左右的性能提升</span></span><br><span class="line">            odd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number[even] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; odd &lt; even)&#123;</span><br><span class="line">            even--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (odd &lt; even)&#123;</span><br><span class="line">            temp = number[odd];</span><br><span class="line">            number[odd] = number[even];</span><br><span class="line">            number[even] = temp;</span><br><span class="line">            odd++;</span><br><span class="line">            even--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h3><blockquote>
<p>剑指 Offer 29. 顺时针打印矩阵 - 解决方案<br>题目描述<br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100<br>注意：本题与主站 54 题 相同</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：二维数组<br>整体思路：循环遍历整个数组，循环中再嵌套四个循环，分别是从左至右，从上至下，从右至左，从下至上这几个方向，按照题意将整个数组遍历完成，控制好边界<br>m 为行数，n 为列数，时间复杂度：O(mn)，空间复杂度：O(1)<br><strong>算法流程</strong><br>题目中 <code>matrix</code> 有可能为空，直接返回空数组即可<br>初始化边界 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 四个值，初始化结果数组 <code>res</code> 和数组下标 <code>x</code>按照遍历方向循环取出数字放入结果数组中<br>从左至右：遍历完成后 <code>++top</code>，如果 <code>top</code> &gt; <code>bottom</code>，到达边界循环结束<br>从上至下：遍历完成后 <code>--right</code>，如果 <code>left</code> &gt; <code>right</code>，到达边界循环结束<br>从右至左：遍历完成后 <code>--bottom</code>，如果 <code>top</code> &gt; <code>bottom</code>，到达边界循环结束<br>从下至上：遍历完成后 <code>++left</code>，如果 <code>left</code> &gt; <code>right</code>，到达边界循环结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   剑指 Offer 29. 顺时针打印矩阵</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[(right+<span class="number">1</span>) * (bottom+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            result[x++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; bottom)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; i++)&#123;</span><br><span class="line">            result[x++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--)&#123;</span><br><span class="line">            result[x++] = matrix[bottom][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--bottom &lt; top)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt;= top; i--)&#123;</span><br><span class="line">            result[x++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h3><blockquote>
<p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例  1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2<br>限制：</p>
<p>1 &lt;= 数组长度 &lt;= 50000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：摩尔投票<br>本题常见解法共有 3 种<br><strong>数组排序</strong>：首先将 <code>nums</code> 排序，由于该数字超过数组长度的一半，所以数组的中间元素就是答案，时间复杂度为 <code>O(nlogn)</code><br><strong>哈希计数</strong>：遍历 <code>nums</code> 数组，将数字存在 <code>HashMap</code> 中，统计数字出现次数，统计完成后再遍历一次 <code>HashMap</code>，找到超过一半计数的数字，时间复杂度为 O(n)<br><strong>摩尔投票</strong>：遍历 <code>nums</code> 数组，使用 <code>count</code> 进行计数，记录当前出现的数字为 <code>cur</code>，如果遍历到的 <code>num</code> 与 <code>cur</code> 相等，则 <code>count</code> 自增，否则自减，当其减为 0 时则将 <code>cur</code> 修改为当前遍历的 <code>num</code>，通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)O<br>摩尔投票是最优解法，时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>初始化：预期结果 <code>cur = 0</code> 和计数器 <code>count = 0</code><br>遍历数组 <code>nums</code>，遍历过程中取到的数字为 <code>num</code><br>当 <code>count</code> 为 0 时，表示不同的数字已经将当前的结果抵消掉了，可以换新的数字进行尝试，则 <code>cur = num</code><br>当 <code>num == cur</code> 时，表示遍历数字和预期结果相同，则计数器 <code>count++</code><br>当 <code>num != cur</code> 时，表示遍历数字和预期结果不同，则计数器 <code>count--</code><br>最终留下的数字 <code>cur</code> 就是最终的结果，出现次数超过一半的数字一定不会被抵消掉，最终得到了留存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 剑指 Offer 39. 数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="comment">* 方法一：排序法</span></span><br><span class="line"><span class="comment">*  时间复杂度  O(N log_2 N) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line">    <span class="keyword">while</span>(end &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[start] == numbers[end])&#123;</span><br><span class="line">            <span class="keyword">if</span> ((end - start + <span class="number">1</span>) &gt; (len/<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[start];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法二： 哈希表解法</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement_b</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(numbers[i])) &#123;</span><br><span class="line">            count = hashMap.get(numbers[i]);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; numbers.length / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hashMap.put(numbers[i],count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(numbers[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  法三：投票法</span></span><br><span class="line"><span class="comment">*  时间复杂度 O(N)</span></span><br><span class="line"><span class="comment">*  空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement_c</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> votes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == votes)&#123;</span><br><span class="line">            x = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == numbers[i]) &#123;</span><br><span class="line">            votes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            votes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == x)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; numbers.length / <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-57-和为-s-的两个数字"><a href="#剑指-Offer-57-和为-s-的两个数字" class="headerlink" title="剑指 Offer 57. 和为 s 的两个数字"></a>剑指 Offer 57. 和为 s 的两个数字</h3><blockquote>
<p>题目描述<br>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]<br>限制：</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p>
</blockquote>
<p><strong>解题方案</strong></p>
<p>标签：双指针<br>整体思路：因为数组本身是有序的，那么完全可以在数组的开头 <code>start</code> 和结尾 <code>end</code> 位置各设置一个指针，通过二者的加和 <code>sum</code> 来找到目标值 <code>target</code>，如果 <code>sum</code> &lt; <code>target</code>，则 <code>start++</code>，这样可以让下一次的 <code>sum</code> 变大，如果 <code>sum</code> &gt; <code>target</code>，则 <code>end--</code>，这样可以让下一次的 <code>sum</code> 变小，找到结果<br>时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>首先初始化 <code>start = 0，end = nums.length - 1</code>，作为双指针<br>当 <code>start</code> &lt; <code>end</code> 时，始终进行循环遍历<br>计算 <code>sum = nums[start] + nums[end]</code>，并将 <code>sum</code> 与 <code>target</code> 进行比较<br>如果 <code>sum &lt; target</code>，则需要将下一次的 <code>sum</code> 值变大，因为数组有序，故而 <code>start++</code><br>如果 <code>sum &gt; target</code>，则需要将下一次的 <code>sum</code> 值变小，因为数组有序，故而 <code>end--</code><br>如果 <code>sum == target</code>，则找到了最终的结果，将结果返回即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 57. 和为 s 的两个数字</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (numbers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[start] + numbers[end] &gt; i)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[start] + numbers[end] &lt; i) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[<span class="number">0</span>] = numbers[start];</span><br><span class="line">            result[<span class="number">1</span>] = numbers[end];</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-58-翻转单词顺序"><a href="#剑指-Offer-58-翻转单词顺序" class="headerlink" title="剑指 Offer 58. 翻转单词顺序"></a>剑指 Offer 58. 翻转单词顺序</h3><blockquote>
<p>题目描述<br>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 “I am a student. “，则输出 “student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p><strong>方法一：分隔+倒序</strong></p>
<p>​    利用 “字符串分割”、“列表倒序” 的内置函数 <em>（面试时不建议使用）</em> ，可简便地实现本题的字符串翻转要求。</p>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer58.png" alt="1598026314901"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - I. 翻转单词顺序</span></span><br><span class="line"><span class="comment">*  方法一： 分隔 + 倒叙</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseWords</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">    String[] reverseWords = words.trim().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = reverseWords.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sb.append(reverseWords[i]);</span><br><span class="line">        sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong></p>
<p>​    先将开头和结尾处多余的空格去掉，从后向前遍历，通过前后指针锁定单词，跳过中间空格，最终将整个句子中的单词反转<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<p><strong>算法流程</strong></p>
<ol>
<li>首先将原始字符串去掉开头和结尾的空格得到 <code>tmp</code>，便于之后直接从单词处理开始；</li>
<li>初始化单词起始位置 <code>start</code> 和单词结束位置 <code>end</code> 指针，位置在字符串结尾处；</li>
<li>初始化结果字符串 <code>res</code> 为空字符串；</li>
<li>当 <code>start &gt;= 0</code> 时，说明字符串未遍历结束，作为循环条件</li>
<li>在 <code>tmp[start]</code> 位置如果不为空格，说明还没有获取到完整的单词，则 <code>start--</code></li>
<li>获取到完整单词之后，截取 <code>[start+1, end+1]</code> 这一段字符串加入结果字符串中，反转单词<br> 在 <code>tmp[start]</code> 位置如果为空格，说明还没有到下一个单词的结尾位置，则 <code>start--</code></li>
<li>到单词结尾位置之后，<code>end = start</code>，往复进行上述流程，将单词全部反转</li>
<li>将结果字符串 <code>res</code> 去掉开头和结尾多余的空格</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - I. 翻转单词顺序</span></span><br><span class="line"><span class="comment">*  方法二： 双指针</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseWords_b</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">    String reverseWords = words.trim();</span><br><span class="line">    <span class="keyword">int</span> end = reverseWords.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = end;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; reverseWords.charAt(start) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(reverseWords.substring(start+<span class="number">1</span>, end+<span class="number">1</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        end = start;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; reverseWords.charAt(end) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        start = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-58-左旋转字符串-解决方案"><a href="#剑指-Offer-58-左旋转字符串-解决方案" class="headerlink" title="剑指 Offer 58. 左旋转字符串 - 解决方案"></a>剑指 Offer 58. 左旋转字符串 - 解决方案</h3><blockquote>
<p>题目描述<br>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”<br>限制：</p>
<p>1 &lt;= k &lt; s.length &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：字符串遍历<br>整体思路：在原字符串处从需要反转的位置 n 开始向后遍历，并保存到结果字符串中，然后再从原字符串的初始位置遍历到位置 n，继续添加到结果字符串<br>时间复杂度：O(n)，空间复杂度：O(n)<br><strong>算法流程</strong><br>初始化结果字符串 <code>res = &quot;&quot;</code>，获取字符串长度 <code>len</code><br>从下标 <code>n</code> 开始遍历，遍历到字符串 <code>s</code> 结尾，将区间 <code>[n, len]</code> 的字符添加到 <code>res</code> 中<br>从下标 <code>0</code> 开始遍历，遍历到下标 <code>n</code> 位置，将区间 <code>[0, n]</code> 的字符添加到 <code>res</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - II. 左旋转字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseLeftWords</span><span class="params">(String words, <span class="keyword">int</span> numbers)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(words.substring(numbers, words.length()));</span><br><span class="line">    sb.append(words.substring(<span class="number">0</span>, numbers));</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">        int len = words.length();</span></span><br><span class="line"><span class="comment">        for (int i = numbers; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">            sb.append(words.charAt(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; numbers; i++) &#123;</span></span><br><span class="line"><span class="comment">            sb.append(words.charAt(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sb.toString();*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue-Stack"><a href="#Queue-Stack" class="headerlink" title="Queue/Stack"></a>Queue/Stack</h2><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><blockquote>
<p>题目描述<br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<p>输入：head = [1,3,2]<br>输出：[2,3,1]<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：栈<br>栈的特点是先进后出，因为题目要求从尾到头打印元素，所以符合栈的特性<br>先遍历一遍链表，将链表中的元素存入到栈中<br>再不断弹出栈内元素，将弹出元素存放到结果数组中<br>也有使用递归来进行解题的，在此提出一个思考，递归和栈的关系是什么？其实递归的本质也是在使用栈，只不过是程序调用栈，因为没有显式在代码中体现出来，所以常常被忽略了<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reversePrint(ListNode head)&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = stack.size();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        result[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><blockquote>
<p>题目描述<br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。（若队列中没有元素，deleteHead 操作返回 -1）</p>
<p>示例 1：</p>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p>
<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p>
<p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：栈和队列<br>整体思路：栈实现队列的本质就是负负得正，两次先进后出的结果就是先进先出了。在构造函数中完成两个栈的初始化工作，在 <code>appendTail</code> 函数中向其中一个栈 <code>stack1</code> 结尾插入整数，在 <code>deleteHead</code> 函数中如果 <code>stack2</code> 为空，则将 <code>stack1</code> 的值全部弹出放到 <code>stack2</code> 中，再从 <code>stack2</code> 中取值，这样达到了负负为正的队列效果<br>时间复杂度：O(1)，空间复杂度：O(n)</p>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer09.png" alt="1598370329386"><strong>算法流程</strong><br><code>CQueue</code> 构造函数，初始化 <code>stack1</code> 和 <code>stack2</code><br><code>appendTail</code> 函数，将 <code>value</code> 加到 <code>stack1</code> 里面，先进后出<br><code>deleteHead</code> 函数，判断 <code>stack2</code> 是否为空，如果为空则将当前 <code>stack1</code> 中的所有值都弹出放入 <code>stack2</code> 中。此时由于 <code>stack2</code> 也是先进后出，所以如果 <code>stack2</code> 不为空，则将其尾部值弹出，实现了先进先出队列的效果，如果 <code>stack2</code> 为空，则返回 -1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 09. 用两个栈实现队列</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment">* obj.appendTail(value);</span></span><br><span class="line"><span class="comment">* int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-30-包含-min-函数的栈"><a href="#剑指-Offer-30-包含-min-函数的栈" class="headerlink" title="剑指 Offer 30. 包含 min 函数的栈"></a>剑指 Offer 30. 包含 min 函数的栈</h3><blockquote>
<p>题目描述<br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)O(1)。</p>
<p>示例:</p>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.<br>提示：</p>
<p>各函数的调用总次数不超过 20000 次</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：辅助栈<br>整体思路：<code>push</code>、<code>pop</code>、<code>top</code> 操作可以通过建立普通的栈结构完成操作，对于取最小值 <code>min</code> 函数则需要建立辅助栈，辅助栈中降序存储 <code>push</code> 过程中的值<br>时间复杂度：<code>O(1)</code>，空间复杂度：<code>O(n)</code><br><strong>算法流程</strong><br><code>MinStack</code> 构造函数中初始化数据栈 <code>stack1</code> 和辅助栈 <code>stack2</code><br><code>push</code> 函数中将 <code>x</code> 正常添加到 <code>stack1</code> 中，如果 <code>stack2</code> 为空或者 <code>stack2</code> 栈顶值大于等于 <code>x</code> 时，则将 <code>x</code> 加入 <code>stack2</code> 中，这样保证了 <code>stack2</code> 中的值一定是降序的，存储的数量会小于等于 <code>stack1</code><br><code>pop</code> 函数中首先 <code>stack1</code> 需要将值 <code>pop</code> 出去，如果 <code>stack2</code> 栈顶数据与 <code>stack1</code> 栈顶数据相等，则将 <code>stack2</code> 的值也 <code>pop</code> 出去，保证数据栈和辅助栈的数据一致性<br><code>top</code> 函数则直接取 <code>stack1</code> 栈顶值即可<br><code>min</code> 函数则直接取 <code>stack2</code> 栈顶值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 30. 包含 min 函数的栈</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment">* obj.push(x);</span></span><br><span class="line"><span class="comment">* obj.pop();</span></span><br><span class="line"><span class="comment">* int param_3 = obj.top();</span></span><br><span class="line"><span class="comment">* int param_4 = obj.min();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; numStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        numStack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= minStack.peek())&#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* if (numStack.pop().equals(minStack.peek()))&#123;</span></span><br><span class="line"><span class="comment">                minStack.pop();</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        <span class="keyword">if</span> (!numStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (numStack.peek().equals(minStack.peek()))&#123; </span><br><span class="line">      <span class="comment">//使用if (numStack.peek() == minStack.peek())&#123; 会出错</span></span><br><span class="line">     <span class="comment">//.equals()方法和==相等判断有什么区别？ https://www.imooc.com/wenda/detail/505519</span></span><br><span class="line">                minStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            numStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="equals-方法和-相等判断有什么区别？"><a href="#equals-方法和-相等判断有什么区别？" class="headerlink" title=".equals()方法和==相等判断有什么区别？"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/505519">.equals()方法和==相等判断有什么区别？</a></h4><p><code>==</code>是比较两个字符串引用的地址是否相同，即是否指向同一个对象，而<code>equals</code>方法则比较字符串的内容是否相同。<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; &quot;abc&quot;;</span><br><span class="line">String b &#x3D; &quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p><code>a == b</code>返回true，<code>a.equals(b)</code>同样返回true。<br>因为程序在运行时有一个字符串池，创建字符串时会先查找池中是否有相应的字符串，如果已经存在的话只需把引用指向它即可，如果没有则新建一个。上例中创建a时，会在字符串池中首先创建一个”<code>abc</code>“，然后a指向它；创建b时，由于”<code>abc</code>“已经存在，b直接指向它即可。<br>若改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a &#x3D; &quot;abc&quot;;</span><br><span class="line">String b &#x3D; new String(&quot;abc&quot;);</span><br></pre></td></tr></table></figure>

<p>则<code>a == b</code>返回false，<code>a.equals(b)</code>返回true。因为创建b时不管”<code>abc</code>“是否存在都会new一个新的”<code>abc</code>“，从而a和b指向的字符创对象是不同的，因此返回false。</p>
<h2 id="HashSet-HashMap"><a href="#HashSet-HashMap" class="headerlink" title="HashSet/HashMap"></a>HashSet/HashMap</h2><h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h3><blockquote>
<p>题目描述<br>在一个长度为 n 的数组 nums 里的所有数字都在 0 ～ n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3<br>限制：</p>
<p>2 &lt;= n &lt;= 100000</p>
</blockquote>
<p><strong>解题方案</strong></p>
<p>方法一：利用hashset的特性</p>
<p>思路：使用 <code>HashSet</code> 来进行处理，因为 <code>HashSet</code> 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可。思路较为简单，就不给图了<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 03. 数组中重复的数字</span></span><br><span class="line"><span class="comment">*  方法一： 利用hashset的特性</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p>方法二：先排序再查找</p>
<p>思路：先排序再查找，排序之后有重复的肯定是挨着的，然后前后两两比较，如果有重复的直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 03. 数组中重复的数字</span></span><br><span class="line"><span class="comment">*  方法二： 先排序再查找</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber_b</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三：使用临时数组</p>
<p>思路：这道题有个很明显的特点，就是数字的大小在<code>0~n-1</code>之间，所以使用上面两种方式肯定不是最好的选择。这里我们可以申请一个临时数组<code>temp</code>，因为<code>nums</code>元素中的每个元素的大小都在<code>0~n-1</code>之间，所以我们可以把<code>nums</code>中元素的值和临时数组temp建立映射关系，就是<code>nums</code>中元素的值是几，我们就把<code>temp</code>中对应的位置值加1，当<code>temp</code>某个位置的值大于1的时候，就表示出现了重复，我们直接返回即可</p>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer03.png" alt="1598109961615"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 03. 数组中重复的数字</span></span><br><span class="line"><span class="comment">*  方法三： 使用临时数组</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber_c</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> [] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        temp[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (temp[nums[i]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法四：放到指定位置</p>
<p>思路：我们还可以不使用临时数组，我们在遍历的时候把数组<code>nums</code>中的值放到对应的位置上，比如某个元素是5，我们就把他放到<code>nums[5]</code>中，每次放入的时候查看一下这个位置是否放入了正确的值，如果已经放入了正确的值，就说明重复了，我们直接返回即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 03. 数组中重复的数字</span></span><br><span class="line"><span class="comment">*  方法四： 放到指定位置</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findRepeatNumber_d</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == i)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[nums[i]])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[nums[i]];</span><br><span class="line">            nums[nums[i]] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a>剑指 Offer 50. 第一个只出现一次的字符</h3><blockquote>
<p>题目描述<br>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例：</p>
<p>s = “abaccdeff”<br>返回 “b”</p>
<p>s = “”<br>返回 “ “<br>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 50000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：哈希</p>
<p>首先遍历字符串，利用<code>HashMap&lt;Character, Boolean&gt;</code>，以第一次出现的字符对为<code>key</code>，对<code>value</code>设置为<code>true</code>，如果再次出现则置为<code>false</code>。然后再遍历一次字符串，在找到第一个<code>value</code>值为<code>true</code>对应的<code>key</code>即为第一个只出现一次的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 50. 第一个只出现一次的字符</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character,Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Boolean&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(str.charAt(i)))&#123;</span><br><span class="line">            map.put(str.charAt(i), <span class="keyword">false</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(str.charAt(i), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.get(str.charAt(i)))&#123;</span><br><span class="line">            <span class="keyword">return</span> str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h3><blockquote>
<p>题目描述<br>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.<br>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：链表遍历<br>整体思路是使用挨着的前后 2 个指针，当前方指针遇到要删除的值时，则使用后方指针重新构造连接并跳过该值<br>首先判断头指针是否为 <code>null</code>，如果为空则直接返回 <code>null</code><br>如果头指针 <code>head.val</code> 即为要删除的值，则直接返回 <code>head.next</code> 即可<br>初始化前指针 <code>pre</code> 和后指针 <code>post</code>，两个指针紧挨着，距离为 1<br>前后指针一直遍历链表，直到遍历到链表结尾或等于要删除的值时则跳出循环<br>如果找到要删除的值，则令 <code>post.next = pre.next</code>，相当于将链表中的值删除<br>时间复杂度：O(n)，空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 18. 删除链表的节点</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.val == value)&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode post = head;</span><br><span class="line">    ListNode pre = head.next;</span><br><span class="line">    <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val != value)&#123;</span><br><span class="line">        post = pre;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)&#123;</span><br><span class="line">        post.next = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-22-链表中倒数第-k-个节点"><a href="#剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第 k 个节点"></a>剑指 Offer 22. 链表中倒数第 k 个节点</h3><blockquote>
<p>题目描述<br>输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
</blockquote>
<p><strong>解题方案</strong></p>
<p>方法一：两次遍历链表</p>
<p>首先遍历整条链表，算出链表的长度<code>length</code>，算出获取所需链表需要执行<code>length - k</code>步，再一次遍历链表至第<code>length- k</code>个结点所获取的头指针即为所需</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 22. 链表中倒数第 k 个节点</span></span><br><span class="line"><span class="comment">*  方法一： 两次遍历</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    ListNode result = head;</span><br><span class="line">    <span class="keyword">while</span>(head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = length - k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            result = result.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<p>标签：链表遍历<br>整体思路是使用双指针，间隔 k 个位置，同时向后移动，当前方指针移动到尾部时，后方指针的位置就是倒数第 k 个数字<br>首先构建前指针 <code>pre</code>，后指针 <code>post</code><br>前指针 <code>pre</code> 向前移动 k 个位置<br>前指针 <code>pre</code> 和后指针 <code>post</code> 同时向前移动，直到前指针为 <code>null</code> 时停止<br>后指针 <code>post</code> 即为倒数第 k 个数字<br>时间复杂度：O(n)，空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 22. 链表中倒数第 k 个节点</span></span><br><span class="line"><span class="comment">*  方法二： 双指针</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd_b</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode post = head;</span><br><span class="line">    ListNode prev = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">        post = post.next;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a>剑指 Offer 25. 合并两个排序的链表</h3><blockquote>
<p>题目描述<br>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例 1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 1000</p>
</blockquote>
<p><strong>解题方案</strong></p>
<p>方法一：链表合并</p>
<p>首先，找到两个链表中最小的结点为头结点，并记录，然后重新排序<code>l1</code>和<code>l2</code>的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 25. 合并两个排序的链表</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、找到头结点，并记录</span></span><br><span class="line">    ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">    ListNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">        temp = l1;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        temp = l2;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    result = temp;</span><br><span class="line">    <span class="comment">//2、重新排序l1和l2，并入temp</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：递归</p>
<p>标签：链表、递归<br>这道题可以使用递归实现，新链表也不需要构造新节点<br>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束<br>返回值：每一层调用都返回排序好的链表头<br>本级递归内容：如果 <code>l1</code> 的 <code>val</code> 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理<br><code>O(m+n)</code>，<code>m</code> 为 <code>l1</code> 的长度，<code>n</code> 为 <code>l2</code> 的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 25. 合并两个排序的链表</span></span><br><span class="line"><span class="comment">*  方法二： 递归法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists_b</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists_b(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l2.next = mergeTwoLists_b(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a>剑指 Offer 52. 两个链表的第一个公共节点</h3><blockquote>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer52a.png" alt="1598160392043"></p>
<p>在节点 c1 开始相交。</p>
<p> <img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/offer52b.png" alt="1598160407568"></p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Reference of the node with value = 8<br>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
</blockquote>
<p><strong>解决思路：</strong></p>
<p>标签：双指针链表遍历<br>分别构造 2 个指针去遍历 2 个链表，无论哪个指针到尾部时，让其重新回到对方的头部，最终会在第一个公共节点相遇，如果没有，则会在 <code>null</code> 处相遇<br>时间复杂度：设 A 链表非公共长度为 <code>m</code>，B 链表非公共长度为 <code>n</code>，公共部分为 <code>b</code>，则复杂度为 <code>O(m+n+b)</code>，空间复杂度：<code>O(1)</code><br><strong>算法流程</strong><br>使用 <code>headA</code> 和 <code>headB</code> 初始化 2 个指针 <code>curA</code> 和 <code>curB</code>，用来遍历使用进行循环遍历，直到 <code>curA</code> 和 <code>curB</code> 相同时结束。遍历过程中如果 <code>curA</code> 到尾部则将其重新放回头部 <code>headB</code>，如果 <code>curB</code> 到尾部则将其重新放回头部 <code>headA</code>。循环结束时在第一个公共节点相遇，返回该节点 <code>curA</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 52. 两个链表的第一个公共节点</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode curA = headA;</span><br><span class="line">    ListNode curB = headB;</span><br><span class="line">    <span class="keyword">while</span> (curA != curB) &#123;</span><br><span class="line">        curA = curA != <span class="keyword">null</span> ? curA.next : headB;</span><br><span class="line">        curB = curB != <span class="keyword">null</span> ? curB.next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>常见排序算法的时间复杂度和空间复杂度如下表：</p>
<p><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律；</p>
<p><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数；</p>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p>
<p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面；</p>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/sort.jpg" alt="preview"></p>
<h3 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a><strong>Bubble Sort</strong></h3><p>​冒泡排序：</p>
<ol>
<li>比较相邻两个元素的值，如果第一个比第二个大，则交换；</li>
<li>对数组上的数据逐个比较，每次将最大的值通过冒泡排到最后一位；</li>
<li>针对所有的元素重复1~2，除了最后一个；</li>
<li>重复1~3，直到排序完成；    </li>
</ol>
<p><img src="/hexo/home/git/hexo/2020/08/09/Data-Structures-and-Algorithm/bubble_sort.webp" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Bubble sort</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a><strong>Selection Sort</strong></h3><p>选择排序：</p>
<ol>
<li>在未排序序列中找到最小（大）值，并存放在排列序列的其实位置；</li>
<li>重复1，继续找剩余未排序序列中的最小（大）值，直至结束；</li>
</ol>
<p>![img](Data-Structures-and-Algorithm/Selection Sort.webp)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Select sort</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Insert-Sort"><a href="#Insert-Sort" class="headerlink" title="Insert Sort"></a>Insert Sort</h3><p>插入排序原理：通过构建有序序列，对于未排序的数据，在已排序序列中从后向前扫描，找到对于的位置插入。</p>
<p>执行过程：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已排序的元素序列中从后往前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一个位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该元素位置后；</li>
<li>重复步骤2~5；</li>
</ol>
<p>![img](Data-Structures-and-Algorithm/Insert Sort.webp)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  insert sort</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        cur = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; cur &lt; arr[preIndex])&#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Shell-sort"><a href="#Shell-sort" class="headerlink" title="Shell sort"></a>Shell sort</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。根据步长由长（一般为数组长度的一半）到短分组，进行排序，直到步长为1为止，属于插入排序的一种。</p>
<p>![img](Data-Structures-and-Algorithm/Shell sort.webp)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  shell sort</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = len / <span class="number">2</span>; step &gt; <span class="number">0</span>; step = step / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = i - step;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; arr[i]) &#123;</span><br><span class="line">                arr[preIndex + step] = arr[preIndex];</span><br><span class="line">                preIndex -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preIndex + step] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>核心思想:</p>
<p>1.在待排序的元素任取一个元素作为基准(通常选第一个元素，称为基准元素）</p>
<p>2.将待排序的元素进行分块，比基准元素大的元素移动到基准元素的右侧，比基准元素小的移动到作左侧，从而一趟排序过程，就可以锁定基准元素的最终位置</p>
<p>3.对左右两个分块重复以上步骤直到所有元素都是有序的（递归过程）</p>
<p>![preview](Data-Structures-and-Algorithm/Quick Sort.jpg)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  Quick sort</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">        <span class="keyword">int</span> L = left;</span><br><span class="line">        <span class="keyword">int</span> R = right;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; temp &lt;= arr[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; temp) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                arr[right] = arr[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = temp;</span><br><span class="line">        quickSort(arr, L, left - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, left + <span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>归并排序的主要思想是分治法。主要过程是：</p>
<ol>
<li>将n个元素从中间切开，分成两部分。（左边可能比右边多1个数）</li>
<li>将步骤1分成的两部分，再分别进行递归分解。直到所有部分的元素个数都为1。</li>
<li>从最底层开始逐步合并两个排好序的数列。</li>
</ol>
<p>![img](Data-Structures-and-Algorithm/Merge Sort.webp)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   Merge Sort</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(arr, left, mid, temp);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>,right,temp);</span><br><span class="line">        MergeArrays(arr, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeArrays</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstLeft = left;</span><br><span class="line">    <span class="keyword">int</span> firstRight = mid;</span><br><span class="line">    <span class="keyword">int</span> secondLeft = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> secondRight = right;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(firstLeft &lt;= firstRight &amp;&amp; secondLeft &lt;= secondRight)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[firstLeft] &lt; arr[secondLeft])&#123;</span><br><span class="line">            temp[k++] = arr[firstLeft++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[k++] = arr[secondLeft++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(firstLeft &lt;= firstRight)&#123;</span><br><span class="line">        temp[k++] = arr[firstLeft++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(secondLeft &lt;= secondRight)&#123;</span><br><span class="line">        temp[k++] = arr[secondLeft++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        arr[left + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrxy/p/8057657.html">StringBuilder和String的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://www.imooc.com/wenda/detail/505519">.equals()方法和==相等判断有什么区别？</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/hexo/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/hexo/2020/06/21/java/" rel="prev" title="Java核心技术 卷I 读书心得">
                  <i class="fa fa-chevron-left"></i> Java核心技术 卷I 读书心得
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">River Young</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//unpkg.com/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/hexo/js/utils.js"></script><script src="/hexo/js/motion.js"></script><script src="/hexo/js/schemes/muse.js"></script><script src="/hexo/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
