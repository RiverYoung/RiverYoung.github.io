<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Array&#x2F;String剑指 Offer 04. 二维数组中的查找 剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [[1,   4,  7, 11, 15],[2,   5,  8">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Structures and Algorithm">
<meta property="og:url" content="http://yoursite.com/2020/08/09/Data-Structures-and-Algorithm/index.html">
<meta property="og:site_name" content="River Young">
<meta property="og:description" content="Array&#x2F;String剑指 Offer 04. 二维数组中的查找 剑指 Offer 04. 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [[1,   4,  7, 11, 15],[2,   5,  8">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/09/images/1598026314901.png">
<meta property="article:published_time" content="2020-08-09T06:04:07.000Z">
<meta property="article:modified_time" content="2020-08-21T16:56:21.134Z">
<meta property="article:author" content="River Young">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/09/images/1598026314901.png">

<link rel="canonical" href="http://yoursite.com/2020/08/09/Data-Structures-and-Algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Data Structures and Algorithm | River Young</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">River Young</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">爱技术/爱拍照</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/Data-Structures-and-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="River Young">
      <meta itemprop="description" content="科技呵护未来">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="River Young">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Data Structures and Algorithm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 14:04:07" itemprop="dateCreated datePublished" datetime="2020-08-09T14:04:07+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-22 00:56:21" itemprop="dateModified" datetime="2020-08-22T00:56:21+08:00">2020-08-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Array-String"><a href="#Array-String" class="headerlink" title="Array/String"></a>Array/String</h2><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><blockquote>
<h3 id="剑指-Offer-04-二维数组中的查找-1"><a href="#剑指-Offer-04-二维数组中的查找-1" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>限制：</p>
<p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
</blockquote>
<p><strong>结题思路：</strong></p>
<p>​    第一种是使用暴力破解的方法，遍历整个二维数组直到找到target值或者遍历结束为止，但是该方法是时间复杂度为O(n*m)，不是最优解；</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  剑指offer04.二维数组中的查找</span></span><br><span class="line"><span class="comment">*   方法1：暴力破解的方法</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(n*m)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">                width = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    第二种方法是利用矩阵“从上到下递增，从左到右递增”的特点，将其视为二分查找树，所以可以取左下角的值”18”作为根节点进行开始判断，如果target小于18则往上走一行，如果大于18则往右走一列，直到找到target或者遍历结束为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  剑指offer04.二维数组中的查找</span></span><br><span class="line"><span class="comment">*   方法二</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(m+n)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &gt;= <span class="number">0</span> &amp;&amp; col &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] &gt; target)&#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target)&#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05.替换空格"></a>剑指 Offer 05.替换空格</h3><blockquote>
<p>剑指 Offer 05. 替换空格<br>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<p>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p>​    增加一个新字符串，遍历原来的字符串，遍历过程中，如果非空格则将原来的字符直接拼接到新字符串中，如果遇到空格则将%20拼接到新字符串中<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  剑指 Offer 05. 替换空格</span></span><br><span class="line"><span class="comment">*  时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">*  空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">//StringBuilder和String的区别</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">' '</span>)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">"%2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String str = sb.toString();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <a href="https://www.cnblogs.com/mrxy/p/8057657.html" target="_blank" rel="noopener">StringBuilder和String的区别</a></p>
<h3 id="剑指-Offer-17-打印从-1-到最大的-n-位数"><a href="#剑指-Offer-17-打印从-1-到最大的-n-位数" class="headerlink" title="剑指 Offer 17. 打印从 1 到最大的 n 位数"></a>剑指 Offer 17. 打印从 1 到最大的 n 位数</h3><blockquote>
<p>剑指 Offer 17. 打印从 1 到最大的 n 位数<br>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n = 1<br>输出: [1,2,3,4,5,6,7,8,9]</p>
<p>说明：</p>
<p>用返回一个整数列表来代替打印<br>n 为正整数</p>
</blockquote>
<p><strong>解题思路：</strong><br>    题目要求打印 “从 1 至最大的 n位数的列表” ，因此需考虑以下两个问题：</p>
<p>​    最大的 n 位数（记为 end ）和位数 n 的关系： 例如最大的 1位数是 9，最大的 2 位数是 99 ，最大的 3 位数是 999 。则可推出公式：<br>​    <code>end = 10^n - 1</code></p>
<p>​    <code>大数越界问题</code>： 当 n 较大时，end 会超出 int32整型的取值范围，超出取值范围的数字无法正常存储。但由于本题要求返回 int 类型数组，相当于默认所有数字都在 int32 整型取值范围内，因此不考虑大数越界问题。<br>因此，只需定义区间 [1, 10^n - 1][1,10 n −1] 和步长 11 ，通过 forfor 循环生成结果列表 res 并返回即可。</p>
<p><strong>复杂度分析：</strong><br>    时间复杂度 O(10^n ) ： 生成长度为 10^n 的列表需使用 O(10^n)时间。<br>    空间复杂度 O(1) ： 建立列表需使用 O(1)大小的额外空间（ 列表作为返回结果，不计入额外空间 ）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   剑指Offer17. 打印从 1 到最大的 n 位数</span></span><br><span class="line"><span class="comment">*   时间复杂度 ：O(10n)</span></span><br><span class="line"><span class="comment">*   空间复杂度 ：O(10n)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> number) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>) (Math.pow(<span class="number">10</span>, (<span class="keyword">double</span>) number) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = i + <span class="number">1</span>;</span><br><span class="line">        System.out.println(result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-11-旋转数组的最小数字-解决方案"><a href="#剑指-Offer-11-旋转数组的最小数字-解决方案" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字 - 解决方案"></a>剑指 Offer 11. 旋转数组的最小数字 - 解决方案</h3><blockquote>
<p>题目描述<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p>示例 1：</p>
<p>输入：[3,4,5,1,2]<br>输出：1<br>示例 2：</p>
<p>输入：[2,2,2,0,1]<br>输出：0</p>
</blockquote>
<p><strong>解题思路</strong></p>
<p>标签：二分查找<br>整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果<br>时间复杂度：O(logn)，空间复杂度：O(1)</p>
<p><strong>算法流程</strong><br>初始化下标 <code>left</code> 和 <code>right</code><br>每次计算中间下标 <code>mid = (right + left) / 2</code>，这里的除法是取整运算，不能出现小数；</p>
<p>当 <code>numbers[mid] &lt; numbers[right]</code> 时，说明最小值在 <code>[left, mid]</code> 区间中，则令 <code>right = mid</code>，用于下一轮计算；</p>
<p>当 <code>numbers[mid] &gt; numbers[right]</code> 时，说明最小值在 <code>[mid, right]</code> 区间中，则令 <code>left = mid + 1</code>，用于下一轮计算；</p>
<p>当 <code>numbers[mid] == numbers[right]</code> 时，无法判断最小值在哪个区间之中，此时让 <code>right--</code>，缩小区间范围，在下一轮进行判断；<br><strong>为什么是 right– 缩小范围，而不是 left++？</strong><br>    因为数组是升序的，所以最小值一定靠近左侧，而不是右侧<br>比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  剑指 Offer 11. 旋转数组的最小数字</span></span><br><span class="line"><span class="comment">*   时间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">*   空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[mid] &lt; numbers[right]) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h3><blockquote>
<p>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 - 解决方案<br>题目描述<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<p>输入：nums = [1,2,3,4]<br>输出：[1,3,2,4]<br>注：[3,1,2,4] 也是正确的答案之一。<br>提示：</p>
<p>1 &lt;= nums.length &lt;= 50000<br>1 &lt;= nums[i] &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：双指针<br>整体思路：首先指定前指针 <code>start</code> 和后指针 <code>end</code>，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成<br>时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>初始化前指针 <code>start</code> = 0，后指针 <code>end = nums.length - 1</code><br>当 <code>start</code> &lt; <code>end</code> 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换<br>当 <code>nums[start]</code> 为奇数时，则 <code>start++</code>，直到找到不为奇数的下标为止<br>当 <code>nums[end]</code> 为偶数时，则 <code>end--</code>，直到找到不为偶数的下标为止<br>交换 <code>nums[start]</code> 和 <code>nums[end]</code>，继续下一轮交换<br>返回 <code>nums</code>，即为交换后的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] number) &#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> even = number.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (odd &lt; even) &#123;</span><br><span class="line">        <span class="keyword">while</span>(number[odd] % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; odd &lt; even)&#123; <span class="comment">//判断奇数偶数也可以使用高效模式 (number &amp; 1) != 0 为奇数，否则为偶数 相比于求余法有25%左右的性能提升</span></span><br><span class="line">            odd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(number[even] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; odd &lt; even)&#123;</span><br><span class="line">            even--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (odd &lt; even)&#123;</span><br><span class="line">            temp = number[odd];</span><br><span class="line">            number[odd] = number[even];</span><br><span class="line">            number[even] = temp;</span><br><span class="line">            odd++;</span><br><span class="line">            even--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a>剑指 Offer 29. 顺时针打印矩阵</h3><blockquote>
<p>剑指 Offer 29. 顺时针打印矩阵 - 解决方案<br>题目描述<br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]<br>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100<br>注意：本题与主站 54 题 相同</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：二维数组<br>整体思路：循环遍历整个数组，循环中再嵌套四个循环，分别是从左至右，从上至下，从右至左，从下至上这几个方向，按照题意将整个数组遍历完成，控制好边界<br>m 为行数，n 为列数，时间复杂度：O(mn)，空间复杂度：O(1)<br><strong>算法流程</strong><br>题目中 <code>matrix</code> 有可能为空，直接返回空数组即可<br>初始化边界 <code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code> 四个值，初始化结果数组 <code>res</code> 和数组下标 <code>x</code>按照遍历方向循环取出数字放入结果数组中<br>从左至右：遍历完成后 <code>++top</code>，如果 <code>top</code> &gt; <code>bottom</code>，到达边界循环结束<br>从上至下：遍历完成后 <code>--right</code>，如果 <code>left</code> &gt; <code>right</code>，到达边界循环结束<br>从右至左：遍历完成后 <code>--bottom</code>，如果 <code>top</code> &gt; <code>bottom</code>，到达边界循环结束<br>从下至上：遍历完成后 <code>++left</code>，如果 <code>left</code> &gt; <code>right</code>，到达边界循环结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   剑指 Offer 29. 顺时针打印矩阵</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[(right+<span class="number">1</span>) * (bottom+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            result[x++] = matrix[top][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; bottom)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; i++)&#123;</span><br><span class="line">            result[x++] = matrix[i][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--right &lt; left)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--)&#123;</span><br><span class="line">            result[x++] = matrix[bottom][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (--bottom &lt; top)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt;= top; i--)&#123;</span><br><span class="line">            result[x++] = matrix[i][left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h3><blockquote>
<p>题目描述<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例  1:</p>
<p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]<br>输出: 2<br>限制：</p>
<p>1 &lt;= 数组长度 &lt;= 50000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：摩尔投票<br>本题常见解法共有 3 种<br><strong>数组排序</strong>：首先将 <code>nums</code> 排序，由于该数字超过数组长度的一半，所以数组的中间元素就是答案，时间复杂度为 <code>O(nlogn)</code><br><strong>哈希计数</strong>：遍历 <code>nums</code> 数组，将数字存在 <code>HashMap</code> 中，统计数字出现次数，统计完成后再遍历一次 <code>HashMap</code>，找到超过一半计数的数字，时间复杂度为 O(n)<br><strong>摩尔投票</strong>：遍历 <code>nums</code> 数组，使用 <code>count</code> 进行计数，记录当前出现的数字为 <code>cur</code>，如果遍历到的 <code>num</code> 与 <code>cur</code> 相等，则 <code>count</code> 自增，否则自减，当其减为 0 时则将 <code>cur</code> 修改为当前遍历的 <code>num</code>，通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)O<br>摩尔投票是最优解法，时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>初始化：预期结果 <code>cur = 0</code> 和计数器 <code>count = 0</code><br>遍历数组 <code>nums</code>，遍历过程中取到的数字为 <code>num</code><br>当 <code>count</code> 为 0 时，表示不同的数字已经将当前的结果抵消掉了，可以换新的数字进行尝试，则 <code>cur = num</code><br>当 <code>num == cur</code> 时，表示遍历数字和预期结果相同，则计数器 <code>count++</code><br>当 <code>num != cur</code> 时，表示遍历数字和预期结果不同，则计数器 <code>count--</code><br>最终留下的数字 <code>cur</code> 就是最终的结果，出现次数超过一半的数字一定不会被抵消掉，最终得到了留存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 剑指 Offer 39. 数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="comment">* 方法一：排序法</span></span><br><span class="line"><span class="comment">*  时间复杂度  O(N log_2 N) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line">    <span class="keyword">while</span>(end &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[start] == numbers[end])&#123;</span><br><span class="line">            <span class="keyword">if</span> ((end - start + <span class="number">1</span>) &gt; (len/<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[start];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法二： 哈希表解法</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(N)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(N)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement_b</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(numbers[i])) &#123;</span><br><span class="line">            count = hashMap.get(numbers[i]);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; numbers.length / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hashMap.put(numbers[i],count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(numbers[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  法三：投票法</span></span><br><span class="line"><span class="comment">*  时间复杂度 O(N)</span></span><br><span class="line"><span class="comment">*  空间复杂度 O(1)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">majorityElement_c</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> votes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == votes)&#123;</span><br><span class="line">            x = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == numbers[i]) &#123;</span><br><span class="line">            votes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            votes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == x)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; numbers.length / <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-57-和为-s-的两个数字"><a href="#剑指-Offer-57-和为-s-的两个数字" class="headerlink" title="剑指 Offer 57. 和为 s 的两个数字"></a>剑指 Offer 57. 和为 s 的两个数字</h3><blockquote>
<p>题目描述<br>输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]<br>示例 2：</p>
<p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]<br>限制：</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p>
</blockquote>
<p><strong>解题方案</strong></p>
<p>标签：双指针<br>整体思路：因为数组本身是有序的，那么完全可以在数组的开头 <code>start</code> 和结尾 <code>end</code> 位置各设置一个指针，通过二者的加和 <code>sum</code> 来找到目标值 <code>target</code>，如果 <code>sum</code> &lt; <code>target</code>，则 <code>start++</code>，这样可以让下一次的 <code>sum</code> 变大，如果 <code>sum</code> &gt; <code>target</code>，则 <code>end--</code>，这样可以让下一次的 <code>sum</code> 变小，找到结果<br>时间复杂度：O(n)，空间复杂度：O(1)<br><strong>算法流程</strong><br>首先初始化 <code>start = 0，end = nums.length - 1</code>，作为双指针<br>当 <code>start</code> &lt; <code>end</code> 时，始终进行循环遍历<br>计算 <code>sum = nums[start] + nums[end]</code>，并将 <code>sum</code> 与 <code>target</code> 进行比较<br>如果 <code>sum &lt; target</code>，则需要将下一次的 <code>sum</code> 值变大，因为数组有序，故而 <code>start++</code><br>如果 <code>sum &gt; target</code>，则需要将下一次的 <code>sum</code> 值变小，因为数组有序，故而 <code>end--</code><br>如果 <code>sum == target</code>，则找到了最终的结果，将结果返回即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 57. 和为 s 的两个数字</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (numbers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[start] + numbers[end] &gt; i)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[start] + numbers[end] &lt; i) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result[<span class="number">0</span>] = numbers[start];</span><br><span class="line">            result[<span class="number">1</span>] = numbers[end];</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-58-翻转单词顺序"><a href="#剑指-Offer-58-翻转单词顺序" class="headerlink" title="剑指 Offer 58. 翻转单词顺序"></a>剑指 Offer 58. 翻转单词顺序</h3><blockquote>
<p>题目描述<br>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 “I am a student. “，则输出 “student. a am I”。</p>
<p>示例 1：</p>
<p>输入: “the sky is blue”<br>输出: “blue is sky the”<br>示例 2：</p>
<p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>说明：</p>
<p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</blockquote>
<p><strong>解题思路：</strong></p>
<p><strong>方法一：分隔+倒序</strong></p>
<p>​    利用 “字符串分割”、“列表倒序” 的内置函数 <em>（面试时不建议使用）</em> ，可简便地实现本题的字符串翻转要求。</p>
<p><img src="../images/1598026314901.png" alt="1598026314901"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - I. 翻转单词顺序</span></span><br><span class="line"><span class="comment">*  方法一： 分隔 + 倒叙</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseWords</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">    String[] reverseWords = words.trim().split(<span class="string">" "</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = reverseWords.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        sb.append(reverseWords[i]);</span><br><span class="line">        sb.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong></p>
<p>​    先将开头和结尾处多余的空格去掉，从后向前遍历，通过前后指针锁定单词，跳过中间空格，最终将整个句子中的单词反转<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<p><strong>算法流程</strong></p>
<ol>
<li>首先将原始字符串去掉开头和结尾的空格得到 <code>tmp</code>，便于之后直接从单词处理开始；</li>
<li>初始化单词起始位置 <code>start</code> 和单词结束位置 <code>end</code> 指针，位置在字符串结尾处；</li>
<li>初始化结果字符串 <code>res</code> 为空字符串；</li>
<li>当 <code>start &gt;= 0</code> 时，说明字符串未遍历结束，作为循环条件</li>
<li>在 <code>tmp[start]</code> 位置如果不为空格，说明还没有获取到完整的单词，则 <code>start--</code></li>
<li>获取到完整单词之后，截取 <code>[start+1, end+1]</code> 这一段字符串加入结果字符串中，反转单词<br> 在 <code>tmp[start]</code> 位置如果为空格，说明还没有到下一个单词的结尾位置，则 <code>start--</code></li>
<li>到单词结尾位置之后，<code>end = start</code>，往复进行上述流程，将单词全部反转</li>
<li>将结果字符串 <code>res</code> 去掉开头和结尾多余的空格</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - I. 翻转单词顺序</span></span><br><span class="line"><span class="comment">*  方法二： 双指针</span></span><br><span class="line"><span class="comment">*  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseWords_b</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">    String reverseWords = words.trim();</span><br><span class="line">    <span class="keyword">int</span> end = reverseWords.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = end;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; reverseWords.charAt(start) != <span class="string">' '</span>)&#123;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(reverseWords.substring(start+<span class="number">1</span>, end+<span class="number">1</span>) + <span class="string">" "</span>);</span><br><span class="line">        end = start;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= <span class="number">0</span> &amp;&amp; reverseWords.charAt(end) == <span class="string">' '</span>)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        start = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指-Offer-58-左旋转字符串-解决方案"><a href="#剑指-Offer-58-左旋转字符串-解决方案" class="headerlink" title="剑指 Offer 58. 左旋转字符串 - 解决方案"></a>剑指 Offer 58. 左旋转字符串 - 解决方案</h3><blockquote>
<p>题目描述<br>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”<br>限制：</p>
<p>1 &lt;= k &lt; s.length &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：字符串遍历<br>整体思路：在原字符串处从需要反转的位置 n 开始向后遍历，并保存到结果字符串中，然后再从原字符串的初始位置遍历到位置 n，继续添加到结果字符串<br>时间复杂度：O(n)，空间复杂度：O(n)<br><strong>算法流程</strong><br>初始化结果字符串 <code>res = &quot;&quot;</code>，获取字符串长度 <code>len</code><br>从下标 <code>n</code> 开始遍历，遍历到字符串 <code>s</code> 结尾，将区间 <code>[n, len]</code> 的字符添加到 <code>res</code> 中<br>从下标 <code>0</code> 开始遍历，遍历到下标 <code>n</code> 位置，将区间 <code>[0, n]</code> 的字符添加到 <code>res</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  剑指 Offer 58 - II. 左旋转字符串</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">reverseLeftWords</span><span class="params">(String words, <span class="keyword">int</span> numbers)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(words.substring(numbers, words.length()));</span><br><span class="line">    sb.append(words.substring(<span class="number">0</span>, numbers));</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*  StringBuilder sb = new StringBuilder();</span></span><br><span class="line"><span class="comment">        int len = words.length();</span></span><br><span class="line"><span class="comment">        for (int i = numbers; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">            sb.append(words.charAt(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        for (int i = 0; i &lt; numbers; i++) &#123;</span></span><br><span class="line"><span class="comment">            sb.append(words.charAt(i));</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return sb.toString();*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Queue-Stack"><a href="#Queue-Stack" class="headerlink" title="Queue/Stack"></a>Queue/Stack</h2><h3 id="剑指-Offer-06-从尾到头打印链表-解决方案"><a href="#剑指-Offer-06-从尾到头打印链表-解决方案" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表 - 解决方案"></a>剑指 Offer 06. 从尾到头打印链表 - 解决方案</h3><blockquote>
<p>题目描述<br>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<p>输入：head = [1,3,2]<br>输出：[2,3,1]<br>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
</blockquote>
<p><strong>解题方案</strong><br>标签：栈<br>栈的特点是先进后出，因为题目要求从尾到头打印元素，所以符合栈的特性<br>先遍历一遍链表，将链表中的元素存入到栈中<br>再不断弹出栈内元素，将弹出元素存放到结果数组中<br>也有使用递归来进行解题的，在此提出一个思考，递归和栈的关系是什么？其实递归的本质也是在使用栈，只不过是程序调用栈，因为没有显式在代码中体现出来，所以常常被忽略了<br>时间复杂度：O(n)，空间复杂度：O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reversePrint(ListNode head)&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = stack.size();</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        result[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/mrxy/p/8057657.html" target="_blank" rel="noopener">StringBuilder和String的区别</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag"># 数据结构与算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/21/java/" rel="prev" title="Java核心技术 卷I 读书心得">
      <i class="fa fa-chevron-left"></i> Java核心技术 卷I 读书心得
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-String"><span class="nav-number">1.</span> <span class="nav-text">Array&#x2F;String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-04-二维数组中的查找"><span class="nav-number">1.1.</span> <span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-04-二维数组中的查找-1"><span class="nav-number">1.2.</span> <span class="nav-text">剑指 Offer 04. 二维数组中的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-05-替换空格"><span class="nav-number">1.3.</span> <span class="nav-text">剑指 Offer 05.替换空格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-17-打印从-1-到最大的-n-位数"><span class="nav-number">1.4.</span> <span class="nav-text">剑指 Offer 17. 打印从 1 到最大的 n 位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-11-旋转数组的最小数字-解决方案"><span class="nav-number">1.5.</span> <span class="nav-text">剑指 Offer 11. 旋转数组的最小数字 - 解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><span class="nav-number">1.6.</span> <span class="nav-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-29-顺时针打印矩阵"><span class="nav-number">1.7.</span> <span class="nav-text">剑指 Offer 29. 顺时针打印矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-39-数组中出现次数超过一半的数字"><span class="nav-number">1.8.</span> <span class="nav-text">剑指 Offer 39. 数组中出现次数超过一半的数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-57-和为-s-的两个数字"><span class="nav-number">1.9.</span> <span class="nav-text">剑指 Offer 57. 和为 s 的两个数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-58-翻转单词顺序"><span class="nav-number">1.10.</span> <span class="nav-text">剑指 Offer 58. 翻转单词顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-58-左旋转字符串-解决方案"><span class="nav-number">1.11.</span> <span class="nav-text">剑指 Offer 58. 左旋转字符串 - 解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-Stack"><span class="nav-number">2.</span> <span class="nav-text">Queue&#x2F;Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#剑指-Offer-06-从尾到头打印链表-解决方案"><span class="nav-number">2.1.</span> <span class="nav-text">剑指 Offer 06. 从尾到头打印链表 - 解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">3.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">4.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree"><span class="nav-number">5.</span> <span class="nav-text">Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章"><span class="nav-number">6.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">River Young</p>
  <div class="site-description" itemprop="description">科技呵护未来</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">River Young</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
